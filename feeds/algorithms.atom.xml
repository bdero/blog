<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>bran's blog - Algorithms</title><link href="https://blog.bdero.me/" rel="alternate"></link><link href="https://blog.bdero.me/feeds/algorithms.atom.xml" rel="self"></link><id>https://blog.bdero.me/</id><updated>2013-10-14T23:20:00-04:00</updated><entry><title>(Not-so) infinite simplex noise map in 3D</title><link href="https://blog.bdero.me/infinite-simplex-noise-map-3d.html" rel="alternate"></link><published>2013-10-14T23:20:00-04:00</published><updated>2013-10-14T23:20:00-04:00</updated><author><name>bdero</name></author><id>tag:blog.bdero.me,2013-10-14:/infinite-simplex-noise-map-3d.html</id><summary type="html">&lt;p&gt;I thought this might be a good start for something 3D. It's not-so infinite because the terrain doesn't keep regenerating in front of the camera as you move around (which wouldn't even really take that much refactoring), but the camera's height should keep changing according to the noise even after moving far away from the terrain.&lt;/p&gt;</summary><content type="html">&lt;p&gt;I thought this might be a good start for something 3D. It's not-so infinite because the terrain doesn't keep regenerating in front of the camera as you move around (which wouldn't even really take that much refactoring), but the camera's height should keep changing according to the noise even after moving far away from the terrain.
&lt;!--more--&gt;&lt;/p&gt;
&lt;iframe src="http://bdero.me/threejs-tests/simplexmap/" height="465" width="100%" frameborder="no"&gt;&lt;/iframe&gt;

&lt;h5&gt;&lt;strong&gt;If you don't see anything in the frame above, then either &lt;a title="Check if your browser supports WebGL" href="http://get.webgl.org/" target="_blank"&gt;your browser doesn't support WebGL&lt;/a&gt;, or your graphics driver is not sufficient for initializing a WebGL context.&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;The source code is available on &lt;a title="Simplex terrain map source code" href="https://github.com/bdero/threejs-tests/blob/gh-pages/simplexmap/simplexmap.js" target="_blank"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To use it, just click on it to receive a pointer lock request through your browser. If you're using a flavor of Firefox, the request will display in the form of a balloon popup. When the request is accepted, you'll be able to pan the camera around Quake style. You can also move about the scene using the classic W, S, A, and D keys.&lt;/p&gt;
&lt;p&gt;As the title implies, the shape of the terrain and the Y-position of the camera is determined by a similar simplex noise function (provided by &lt;a title="simplex-noise.js Github repository" href="https://github.com/jwagner/simplex-noise.js" target="_blank"&gt;simplex-noise.js&lt;/a&gt;) to that of which I used in my &lt;a title="Some simplex noise" href="https://blog.bdero.me/some-simplex-noise.html"&gt;previous post&lt;/a&gt;. The only real difference is the fact that I used 2D simplex noise here instead of 3D since I had no interest in making the terrain morph.
That type of thing would totally be useful for morphing a water surface. Though, in that case, one might just consider using a &lt;a title="webgl-noise Github repository" href="https://github.com/ashima/webgl-noise" target="_blank"&gt;vertex shader implementation of simplex noise&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Graphics provided by WebGL via the wonderful &lt;a title="three.js Github repository" href="https://github.com/mrdoob/three.js" target="_blank"&gt;three.js&lt;/a&gt;.&lt;/p&gt;</content><category term="3d"></category><category term="algorithm"></category><category term="browser"></category><category term="canvas"></category><category term="html5"></category><category term="interactive"></category><category term="javascript"></category><category term="minimal"></category><category term="perlin noise"></category><category term="pointer lock controls"></category><category term="quake controls"></category><category term="simplex noise"></category><category term="terrain"></category><category term="three.js"></category><category term="visualization"></category><category term="webgl"></category></entry><entry><title>Some simplex noise</title><link href="https://blog.bdero.me/some-simplex-noise.html" rel="alternate"></link><published>2013-10-06T05:53:00-04:00</published><updated>2013-10-06T05:53:00-04:00</updated><author><name>bdero</name></author><id>tag:blog.bdero.me,2013-10-06:/some-simplex-noise.html</id><summary type="html">&lt;p&gt;Just a tiny simplex noise test with retro colors. c:&lt;/p&gt;</summary><content type="html">&lt;p&gt;Just a tiny simplex noise test with retro colors. c: &lt;!--more--&gt;&lt;/p&gt;
&lt;iframe src="http://bdero.me/ivank-tests/simplexnoise/" height="200" width="100%" frameborder="no"&gt;&lt;/iframe&gt;

&lt;h5&gt;&lt;strong&gt;If you don't see anything in the frame above, then either &lt;a title="Check if your browser supports WebGL" href="http://get.webgl.org/" target="_blank"&gt;your browser doesn't support WebGL&lt;/a&gt;, or your graphics driver is not sufficient for initializing a WebGL context.&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;The source code is available on &lt;a title="Simplex noise test source code" href="https://github.com/bdero/ivank-tests/blob/gh-pages/simplexnoise/simplexnoise.js" target="_blank"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Nothing too too interesting - it just pans around and renders out a 3D simplex noise function, passing through the third dimension over time. You can manually control the pan direction and speed by clicking and dragging the mouse around. I wanted to write a bunch of simplex noise combinations to make different kinds of textures, but I quickly lost interest and figured that moving on to some 3D things might be more fun.&lt;/p&gt;
&lt;p&gt;The colors are precomputed using the same method explained in my previous &lt;a href="https://blog.bdero.me/julia-set-viewer.html" title="Julia set viewer"&gt;Julia set viewer&lt;/a&gt; post. Since I wasn't too interested in writing an implementation myself, the actual simplex noise code was taken from a &lt;a href="https://gist.github.com/banksean/304522#file-perlin-noise-simplex-js" title="banksean's simplex noise implementation" target="_blank"&gt;gist by banksean&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Graphics provided by WebGL via &lt;a href="http://lib.ivank.net/" title="IvanK Lib" target="_blank"&gt;IvanK.js&lt;/a&gt;, though the simplex noise is just being software rendered!&lt;/p&gt;</content><category term="2d"></category><category term="algorithm"></category><category term="browser"></category><category term="canvas"></category><category term="html5"></category><category term="iteration"></category><category term="ivank.js"></category><category term="javascript"></category><category term="minimal"></category><category term="perlin noise"></category><category term="plasma"></category><category term="simplex noise"></category><category term="visualization"></category><category term="webgl"></category></entry><entry><title>Julia set viewer</title><link href="https://blog.bdero.me/julia-set-viewer.html" rel="alternate"></link><published>2013-09-28T23:16:00-04:00</published><updated>2013-09-28T23:16:00-04:00</updated><author><name>bdero</name></author><id>tag:blog.bdero.me,2013-09-28:/julia-set-viewer.html</id><summary type="html">&lt;p&gt;A little bit of fun with fractals!&lt;/p&gt;</summary><content type="html">&lt;p&gt;A little bit of fun with fractals! &lt;!--more--&gt;&lt;/p&gt;
&lt;iframe src="http://bdero.me/ivank-tests/julia/" width="100%" height="465" frameborder="no"&gt;&lt;/iframe&gt;

&lt;h5&gt;&lt;strong&gt;If you don't see anything in the frame above, then either &lt;a title="Check if your browser supports WebGL" href="http://get.webgl.org/" target="_blank"&gt;your browser doesn't support WebGL&lt;/a&gt;, or your graphics driver is not sufficient for initializing a WebGL context.&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;The source code is available on &lt;a title="Julia Set viewer source code" href="https://github.com/bdero/ivank-tests/blob/gh-pages/julia/julia.js" target="_blank"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There's nothing special about the way each pixel's color is determined. It's colored based on the number of iterations it takes a point to escape the given distance bound (in this case, &lt;em&gt;sqrt(10)&lt;/em&gt;) in the Julia set function, just like &lt;a title="How Julia set images are generated" href="http://www.youtube.com/watch?v=2AZYZ-L8m9Q#t=358" target="_blank"&gt;any other typical fractal viewer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I decided to have it precompute the color pallet like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;generateColors&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;colors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Uint32Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;MAX_ITERATIONS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;escapeTime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;red&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;escapeTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;MAX_ITERATIONS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="nx"&gt;red&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;escapeTime&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PI&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nx"&gt;green&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;escapeTime&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PI&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nx"&gt;blue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;escapeTime&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PI&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="nx"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0xff000000&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nx"&gt;red&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nx"&gt;green&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nx"&gt;blue&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...and here's what the color functions look like on a graph, where blue starts off strong and dies off, green peaks in the middle, and red ends up strong:&lt;/p&gt;
&lt;iframe src="http://graph.tk/" id="julia-set-viewer_colorgraph" width="100%" height="200" frameborder="no"&gt; &lt;/iframe&gt;

&lt;script&gt;
var graph=document.getElementById("julia-set-viewer_colorgraph");
graph.onload=function() { function g(m){ graph.contentWindow.postMessage(m,"http://graph.tk") };
g("add:(cos(x*pi)+1)/2"); // Blue
g("add:(-cos(x*pi)+1)/2"); // Red
g("add:sin(x*pi)"); // Green
g("scale:9,3");
g("center:0.5,0.5");
}&lt;/script&gt;

&lt;p&gt;The viewer is made up of a few small components:
&lt;ul&gt;
    &lt;li&gt;A &lt;strong&gt;viewport&lt;/strong&gt;, which finds the rectangle on the complex plane to render based on given &lt;em&gt;translation coordinates&lt;/em&gt;, a &lt;em&gt;zoom multiplier&lt;/em&gt;, and the current &lt;em&gt;window resolution&lt;/em&gt;.&lt;/li&gt;
    &lt;li&gt;A &lt;strong&gt;bitmap&lt;/strong&gt;, which holds the most up-to-date &lt;em&gt;image buffer&lt;/em&gt; to display via WebGL. Sections of it are continuously overwritten by the &lt;strong&gt;renderer&lt;/strong&gt;.&lt;/li&gt;
    &lt;li&gt;A &lt;strong&gt;renderer&lt;/strong&gt;, which calls the Julia set function continuously, limiting each execution time a maximum of &lt;em&gt;20ms&lt;/em&gt; and keeping track of where it left off in the &lt;strong&gt;bitmap&lt;/strong&gt; between each call. It also keeps track of the &lt;em&gt;offset&lt;/em&gt; (a complex number to add to a point each time it's squared in the Julia set function).&lt;/li&gt;
    &lt;li&gt;A &lt;strong&gt;controller&lt;/strong&gt;, which sets up the head-up display &lt;em&gt;buttons&lt;/em&gt;, &lt;em&gt;text&lt;/em&gt;, and user input &lt;em&gt;listeners&lt;/em&gt; to modify the &lt;em&gt;zoom&lt;/em&gt; and &lt;em&gt;center&lt;/em&gt; of the &lt;strong&gt;viewport&lt;/strong&gt; and randomly select new &lt;em&gt;offsets&lt;/em&gt; for the Julia set function.&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;p&gt;Everytime you hit &lt;strong&gt;+&lt;/strong&gt; to zoom in, the &lt;em&gt;zoom&lt;/em&gt; of the &lt;strong&gt;viewport&lt;/strong&gt; is multiplied by &lt;em&gt;1.5&lt;/em&gt;. The &lt;strong&gt;viewport&lt;/strong&gt; generates a rectangle every frame by essentially dividing a given starting rectangle's width and height by the &lt;em&gt;zoom&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Because of this setup, if you zoom in far enough, you'll crash into a pixelated mess:
&lt;img class="aligncenter" alt="julia_zoom" src="https://blog.bdero.me/images/julia_zoom.gif" /&gt;&lt;/p&gt;
&lt;p&gt;This is due to the floating point numbers having limited precision - in the case of JavaScript, floating point numbers are 64-bit. You may also notice that the &lt;strong&gt;viewport&lt;/strong&gt;'s &lt;em&gt;center&lt;/em&gt; snaps while panning when you're zoomed in that far.&lt;/p&gt;
&lt;p&gt;The graphics are provided by WebGL via the wonderful &lt;a href="http://lib.ivank.net/" title="IvanK Lib" target="_blank"&gt;IvanK.js&lt;/a&gt;. The Julia set itself is, however, ironically software rendered - mainly because IvanK.js isn't intended for use alongside low level access to WebGL.. and I wanted to see how fast I could get it to work in pure JavaScript. c:&lt;/p&gt;
&lt;p&gt;No fragment shaders were &lt;del&gt;butchered&lt;/del&gt; written in the making of this demo.&lt;/p&gt;</content><category term="2d"></category><category term="algorithm"></category><category term="browser"></category><category term="canvas"></category><category term="classic"></category><category term="fractal"></category><category term="html5"></category><category term="interactive"></category><category term="iteration"></category><category term="ivank.js"></category><category term="javascript"></category><category term="julia set"></category><category term="mobile"></category><category term="vector graphics"></category><category term="visualization"></category><category term="webgl"></category></entry><entry><title>Tower of Hanoi</title><link href="https://blog.bdero.me/tower-of-hanoi.html" rel="alternate"></link><published>2013-09-22T05:53:00-04:00</published><updated>2013-09-22T05:53:00-04:00</updated><author><name>bdero</name></author><id>tag:blog.bdero.me,2013-09-22:/tower-of-hanoi.html</id><summary type="html">&lt;p&gt;I figured I'd start with something classic.&lt;/p&gt;</summary><content type="html">&lt;p&gt;I figured I'd start with something classic. &lt;!--more--&gt;&lt;/p&gt;
&lt;iframe src="http://bdero.me/ivank-tests/hanoi/" width="100%" height="465" frameborder="no"&gt;&lt;/iframe&gt;

&lt;h5&gt;&lt;strong&gt;If you don't see anything in the frame above, then either &lt;a title="Check if your browser supports WebGL" href="http://get.webgl.org/" target="_blank"&gt;your browser doesn't support WebGL&lt;/a&gt;, or your graphics driver is not sufficient for initializing a WebGL context.&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;The source code is available on &lt;a title="Tower of Hanoi Solver source code" href="https://github.com/bdero/ivank-tests/blob/gh-pages/hanoi/hanoi.js" target="_blank"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It works by generating the optimal solution using the common &lt;a title="Tower of Hanoi recursive solution" href="https://en.wikipedia.org/wiki/Tower_of_Hanoi#Recursive_solution" target="_blank"&gt;recursive algorithm&lt;/a&gt;. It then walks through each step in the solution sequence, shifting disks from peg to peg in order to give a human-friendly visual. It can generate the solution and display it for any number of starting disks. The number of disks to use is passed as an argument to the &lt;strong&gt;Hanoi()&lt;/strong&gt; constructor.&lt;/p&gt;
&lt;p&gt;The generated solution for three disks looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It's organized into steps, where each array element consists of a source peg and destination peg. So the first step says to move the top-most disk of &lt;strong&gt;peg 0&lt;/strong&gt; to &lt;strong&gt;peg 2&lt;/strong&gt;, and the second step says to move the top disk of &lt;strong&gt;peg 0&lt;/strong&gt; to &lt;strong&gt;peg 1&lt;/strong&gt;, etc.. If all of the steps in the sequence were completed, then the disks would be left correctly stacked on top of &lt;strong&gt;peg 2&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If you run your browser's JavaScript console (&lt;strong&gt;Ctrl+Shift+K&lt;/strong&gt; in Firefox, &lt;strong&gt;Ctrl+Shift+J&lt;/strong&gt; in Chromium) and then refresh this page, you can inspect the generated solution array, which is logged after the algorithm completes and before the disks start visually shifting from peg to peg.&lt;/p&gt;
&lt;p&gt;The graphics are provided by WebGL via &lt;a href="http://lib.ivank.net/" target="_blank"&gt;IvanK.js&lt;/a&gt; and &lt;a href="http://tweener.ivank.net/" target="_blank"&gt;Tweener&lt;/a&gt;. IvanK.js is really nice because it abstracts a lot of entity management out of the way, providing lots of conveniences that the Flash API makes available without any of the proprietary garbage attached. Very fun and suitable for fast WebGL games and interactive prototypes!&lt;/p&gt;</content><category term="2d"></category><category term="algorithm"></category><category term="browser"></category><category term="canvas"></category><category term="classic"></category><category term="html5"></category><category term="ivank.js"></category><category term="javascript"></category><category term="minimal"></category><category term="puzzle"></category><category term="recursion"></category><category term="tower of hanoi"></category><category term="tweener"></category><category term="vector graphics"></category><category term="visualization"></category><category term="webgl"></category></entry></feed>